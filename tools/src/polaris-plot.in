#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""polaris-plot is part of the PolarisTools package to create
scientific plots from results of POLARIS simulations.

Examples:
    For usage information please execute:
        $ ./polaris-plot --help
"""

from argparse import RawTextHelpFormatter, ArgumentParser

import numpy as np

__author__ = "Robert Brauer"
__license__ = "GPL"
__version__ = "3.0"
__maintainer__ = "Robert Brauer"
__email__ = "robert.brauer@cea.fr"
__status__ = "Production"

'''
The ArgumentParser is used to obtain the non-optional and optional user input.

Notes:
    Default values of the ArgumentParser are set with None. Unless an option is set/chosen,
    the PolarisTools classes use their default values.
'''

parser = ArgumentParser(
    description='PolarisTools_plot, a plotting tool for POLARIS results:',
    formatter_class=RawTextHelpFormatter)

req_args = parser.add_argument_group('required arguments')
req_args.add_argument('model_name', metavar='model_name', type=str, help='name of the POLARIS model.')
req_args.add_argument('simulation_name', metavar='simulation_name', type=str,
                      help='name of the POLARIS simulation.\n'
                           '    results are stored in:\n'
                           '        "/model_name/simulation_name/simulation_type"')
req_args.add_argument('simulation_type', metavar='simulation_type', type=str,
                      help='type of the POLARIS simulation.\n'
                           '    temp     : temperature distribution\n'
                           '    rat      : radiative torque alignment\n'
                           '    temp_rat : temperature distribution + radiative torque alignment\n'
                           '    dust_mc  : radiation scattered at dust grains (Monte-Carlo)\n'
                           '    dust(X)  : thermal emission of dust grains\n'
                           '                 X can be any combination of:\n'
                           '                 _pa   = perfect alignment\n'
                           '                 _rat  = RAT alignment\n'
                           '                 _idg  = IDG alignment\n'
                           '                 _gold = mechanical alignment\n'
                           '                 _internal = internal alignment\n'
                           '    line     : radiative line transfer\n'
                           '    zeeman   : radiative line transfer (zeeman splitting)')
req_args.add_argument('visualization_type', metavar='visualization_type', type=str,
                      choices=['midplane', 'map', 'sed', 'vel_map', 'int_map',
                               'spectrum', 'mag_field', 'velocity', 'custom'],
                      help='visualization routine.\n'
                           '    midplane  : plot midplane data\n'
                           '    map       : plot polarization maps from RT or MC simulations\n'
                           '    sed       : plot spectral energy distribution from RT or MC simulations\n'
                           '    vel_map   : plot velocity maps\n'
                           '    int_map   : plot integrated velocity map\n'
                           '    spectrum  : plot line spectrum\n'
                           '    velocity  : plot mean line-of-sight velocity\n'
                           '    mag_field : plot magnetic field from zeeman splitting\n'
                      #    '    casa     : convert results to use in CASA\n'
                           '    custom    : execute custom plotting routines')
req_args.add_argument('visualization_input', metavar='visualization_input', nargs='+',
                      help='option for visualization routine.\n'
                           '    midplane : input or output + quantity or all +  xy, xz, or yz\n'
                           '    map, sed : detector ID\n'
                           '        detector ID + wavelength ID (alternatives blelow)\n'
                           '        detector ID + wavelength: minID + maxID\n'
                           '        detector ID + wavelength: minID + maxID + Quantity ID\n'
                           '        detector ID + wavelength: minID + maxID + Quantity: minID + maxID\n'
                           '    vel_map, int_map, spectrum, velocity, mag_field: lineID (alternatives blelow)\n'
                           '        gas species ID + spectral line ID\n'
                           '        gas species ID + spectral line ID + QuantityID\n'
                           '        gas species ID + spectral line ID + Quantity: minID + maxID\n'
                      #    '    casa     : (optional: gas species index) + line index\n'
                           '    custom    : plot routine index')

plot_mod_args = parser.add_argument_group('plot modification')
plot_mod_args.add_argument('--cut', dest='cut_parameter', default=None, type=float, nargs='+',
                        help='create a cut of a map plot\n'
                             '(rotation angle, optional: center position [x, y])')
plot_mod_args.add_argument('--radial', dest='radial_parameter', default=None, type=float, nargs=2,
                        help='create an azimuthally averaged radial profile of a map plot\n'
                             '(center position [x, y])')
plot_mod_args.add_argument('--beam', dest='beam_size', default=None, type=str,
                        help='define beam size to convolve raytrace outputs [m, au, pc, arcsec].')
plot_mod_args.add_argument('--title', dest='plot_title', default=False, action='store_true',
                        help='plot explaining title above/into map plots.')
plot_mod_args.add_argument('--vel_map_plots', dest='nr_of_vel_map_plots', default=None, type=int,
                        help='define the max number of images that are on one vel_map plot.')

zoom_scaling_args = parser.add_argument_group('zooming and scaling')
zoom_scaling_args.add_argument('--zoom', dest='zoom_factor', default=None, type=float,
                               help='define zoom factor to shrink plotted area of raytrace outputs.')
zoom_scaling_args.add_argument('--xzoom', dest='zoom_x_factor', default=None, type=float,
                               help='define zoom factor to shrink X-axis range of raytrace outputs.')
zoom_scaling_args.add_argument('--yzoom', dest='zoom_y_factor', default=None, type=float,
                               help='define zoom factor to shrink Y-axis range of raytrace outputs.')
zoom_scaling_args.add_argument('--xscaling', dest='x_scaling', default=None, type=str, choices=['linear', 'log'],
                                help='plot x-axis with \"linear\" or \"log\" scaling.')
zoom_scaling_args.add_argument('--yscaling', dest='y_scaling', default=None, type=str, choices=['linear', 'log'],
                                help='plot y-axis with \"linear\" or \"log\" scaling.')
zoom_scaling_args.add_argument('--cmap_scaling', dest='cmap_scaling', default=None, type=str, nargs='+',
                               help='plot colomap with \"linear\", \"log\", \"symlog\" (+ linthresh), '
                                    ' or \"power\" (+ exp) scaling.')

units_args = parser.add_argument_group('units')
units_args.add_argument('--ax_unit', dest='ax_unit', default=None, type=str,
                        choices=['arcsec', 'au', 'pc', 'm', 'arb_units'],
                        help='unit used for axis and positioning in plots.\n')
units_args.add_argument('--cmap_unit', dest='cmap_unit', default=None, type=str,
                        choices=['arcsec', 'px', 'nuF'],
                        help='select unit for intensity (Jy/arcsec, Jy/px, nu*F_nu).\n')

cbar_args = parser.add_argument_group('colorbar')
cbar_args.add_argument('--extend', dest='extend', default=None, type=str,
                       choices=['min', 'max', 'both', 'neither'],
                       help='define colorbar extends (automatic if not set)')
cbar_args.add_argument('--cmap', dest='cmap', default=None, type=str,
                       help='define the used colormap via its name')
cbar_args.add_argument('--bad_to_min', dest='bad_to_min', default=False, action='store_true',
                         help='set the bad color of the colormap to the minimum color.')
cbar_args.add_argument('--vmin', dest='vmin', default=None, type=float,
                       help='define minimum value in the colorbar and color image.')
cbar_args.add_argument('--vmax', dest='vmax', default=None, type=float,
                       help='define maximum value in the colorbar and color image.')
cbar_args.add_argument('--xmin', dest='xmin', default=None, type=float,
                       help='define minimum value of the x-axis.')
cbar_args.add_argument('--xmax', dest='xmax', default=None, type=float,
                       help='define maximum value of the x-axis.')
cbar_args.add_argument('--ymin', dest='ymin', default=None, type=float,
                       help='define minimum value of the y-axis.')
cbar_args.add_argument('--ymax', dest='ymax', default=None, type=float,
                       help='define maximum value of the y-axis.')

vector_args = parser.add_argument_group('vector plot')
vector_args.add_argument('--vec_size', dest='vec_field_size', default=None, type=int,
                         help='define vector size in vector arrows.\n'
                              '    (VEC_FIELD_SIZE pixel x VEC_FIELD_SIZE pixel)')
vector_args.add_argument('--vec_color', dest='vec_color', default=None, type=str,
                         help='define color of vector plots.\n')
vector_args.add_argument('--no_vec', dest='no_vec', default=False, action='store_true',
                         help='plot no vectors in polarization and vector field maps.')

font_color_args = parser.add_argument_group('font and color')
font_color_args.add_argument('--font_env', dest='font_size_env', default=None, type=str,
                             choices=['paper', 'notebook', 'beamer', 'poster'],
                             help='define font size of plots by choosing an environment.\n')
font_color_args.add_argument('--font', dest='font', default=None, type=str,
                             choices=['fira', 'bitstream'], help='define font of plots.\n')
font_color_args.add_argument('--gray_bg', '-g', dest='gray_background', default=False, action='store_true',
                             help='plot figures with light gray as background color.')

output_args = parser.add_argument_group('output')
output_args.add_argument('--tex', '-t', dest='tex_output', default=False, action='store_true',
                        help='create latex tikz output file instead of creating a pdf file.')
output_args.add_argument('--visual', '-v', dest='show_plot', default=False, action='store_true',
                        help='show visualization directly instead of creating a pdf file.')
parser_options = parser.parse_args()


class PlotRoutines:
    """Manages how the plot module plots results from POLARIS simulations.
    """

    def __init__(self, parse_args):
        """Initialise all necessary modules which are required by plot.py

        Args:
            parse_args: Provides all parameters chosen
                by user when executing PolarisTools.
        """
        self.parse_args = parse_args

        ''' #################################
        ######  Get required modules!  ######
        ################################# '''
        # Get math module
        from modules.math import Math
        self.math = Math()

        # Set the default axis unit to consider it also in the file_io class
        if parse_args.ax_unit is None:
            parse_args.ax_unit = 'au'
        if parse_args.nr_of_vel_map_plots is not None:
            self.nr_of_vel_map_plots = parse_args.nr_of_vel_map_plots
        else:
            self.nr_of_vel_map_plots = 8

        # Get model module
        from modules.model import ModelChooser
        model_chooser = ModelChooser(parse_args)
        self.model = model_chooser.get_module()

        # Get server/cluster module
        from modules.server import ServerChooser
        server_chooser = ServerChooser(parse_args, 'plot')
        self.server = server_chooser.get_module()

        # Get file input/output module
        from modules.file import FileIO
        self.file_io = FileIO(self.model, self.server, parse_args, '@POLARIS@', 'plot')

        # Set the indices for visualizations depending on the user input
        self.set_plot_indizes()

    def plot_map(self):
        """Plot Raytrace or Monte-Carlo results as map from POLARIS simulations.
        """
        # Create pdf file if show_plot is not chosen and read map data from file
        plot_data, header, plot_data_type = self.file_io.read_emission_map(
            'polaris_detector_nr' + str(self.detector_index).zfill(4))
        if plot_data_type == 'map':
            self.file_io.init_plot_output('emission_map_detector_nr' + str(self.detector_index).zfill(4))
        elif plot_data_type == 'cut':
            self.file_io.init_plot_output('emission_map_cut_detector_nr' + str(self.detector_index).zfill(4))
        elif plot_data_type == 'radial':
            self.file_io.init_plot_output('emission_map_radial_detector_nr' + str(self.detector_index).zfill(4))
        elif plot_data_type == 'healpix':
            self.file_io.init_plot_output('emission_healpix_map_detector_nr' + str(self.detector_index).zfill(4))
        # Define title and amount of components per map
        if self.parse_args.simulation_type == 'dust_mc':
            emission_types = r'$\mathsf{Monte-Carlo\ (scattering)}$'
        elif self.parse_args.simulation_type == 'dust_full':
            emission_types = r'$\mathsf{MC+raytracing\ (total\ emission)}$'
        elif self.parse_args.simulation_type == 'dust' or 'dust_' in self.parse_args.simulation_type:
            emission_types = r'$\mathsf{raytracing\ (thermal\ emission)}$'
        else:
            raise ValueError('Emission map cannot be created with the simulation type: ' +
                             self.parse_args.simulation_type)
        # Set stop_index to maximum number of wavelengths
        if self.stop_index is None or self.stop_index > int(header['nr_wavelengths']):
            self.stop_index = int(header['nr_wavelengths'])
        if self.start_index > int(header['nr_wavelengths']):
            raise ValueError('Chosen wavelength(s) are not in the fits file.\n'
                'It is not the ID from the dust catalog, '
                'but the id of all simulated wavelength of the chosen detector!')
        # Create one plot per component of the simulation
        for i_quantity in range(self.quantity_index_start - 1, self.quantity_index_stop):
            # Take colorbar label from quantity id
            cbar_label = self.file_io.get_quantity_labels(i_quantity)
            for i_wl in range(self.start_index - 1, self.stop_index):
                if self.parse_args.plot_title:
                    map_title = emission_types + r'$,\ \lambda=\SI{' + \
                        str(self.math.latex_float(header['wavelengths'][i_wl] * 1e6)) + r'}{\micro\metre}$'
                else:
                    map_title = ''
                if plot_data_type == 'map':
                    # Take data for current quantity
                    tbldata = plot_data[i_quantity, i_wl, :, :]
                    # Create Matplotlib figure
                    plot = Plot(self.model, self.parse_args)
                    # Plot title if chosen
                    if self.parse_args.plot_title:
                        plot.plot_title(map_title)
                    if i_quantity in [0, 6, 7]:
                        # Intensity plot
                        plot.plot_imshow(tbldata, cbar_label=cbar_label, set_bad_to_min=True)
                    elif i_quantity in [4, 5]:
                        # polarization plots
                        plot.plot_imshow(tbldata, cbar_label=cbar_label, set_bad_to_min=True, cmap='magma')
                    elif i_quantity in [1, 2, 3]:
                        # Plot polarization fluxes symmetrically around zero
                        if np.nanmax(np.abs(tbldata)) > 0.:
                            maximum_flux = np.asscalar(np.nanmax(np.abs(tbldata)))
                        else:
                            maximum_flux = 1.0
                        plot.plot_imshow(tbldata, cmap='coolwarm', vmin=-maximum_flux,
                            vmax=maximum_flux, extend='neither', cbar_label=cbar_label)
                    if i_quantity in [4, 5] and not self.parse_args.no_vec:
                        # For PI and P, plot polarization vectors
                        vec_field_data = self.file_io.read_polarization_vectors(plot_data[:, i_wl, :, :])
                        if vec_field_data is not None:
                            vector_color = self.math.get_vector_color(plot_data[i_quantity, i_wl, :, :],
                                cmap=plot.cmap, cmap_scaling=self.parse_args.cmap_scaling, vec_color=self.parse_args.vec_color)
                            plot.plot_quiver(vec_field_data, color=vector_color)
                            plot.plot_pol_vector_text(vec_per_width=len(vec_field_data[:, 0, 0]),
                                color=vector_color, max_pol_degree=float(np.nanmax(
                                np.linalg.norm(vec_field_data[:, :, :], axis=2))))
                elif plot_data_type in ['cut', 'radial']:
                    # Extract 1D information from data
                    [position, data] = plot_data
                    # Plot title if chosen
                    if self.parse_args.plot_title:
                        plot.plot_title(map_title)
                    # Create Matplotlib figure
                    plot = Plot(self.model, self.parse_args, with_cbar=False,
                                ylabel=cbar_label, limits=[position[0], position[-1], None, None])
                    # Plot cut/radial profile
                    plot.plot_line(position, data[i_quantity, i_wl, :])
                elif plot_data_type == 'healpix':
                    # Take data for current quantity
                    wmap_map = plot_data[i_quantity, i_wl, :]
                    # Create Matplotlib figure
                    plot = Plot(self.model, self.parse_args, image_type='healpix')
                    if i_quantity in [0, 6, 7]:
                        # Intensity plot
                        plot.plot_healpix(wmap_map, cbar_label=cbar_label, title=map_title)
                    elif i_quantity in [4, 5]:
                        # polarization plots
                        plot.plot_healpix(wmap_map, cbar_label=cbar_label, title=map_title, cmap='magma')
                    elif i_quantity in [1, 2, 3]:
                        # Plot polarization fluxes symmetrically around zero
                        if np.nanmax(np.abs(wmap_map)) > 0.:
                            maximum_flux = np.asscalar(np.nanmax(np.abs(wmap_map)))
                        else:
                            maximum_flux = 1.0
                        plot.plot_healpix(wmap_map, cmap='coolwarm', vmin=-maximum_flux,
                            vmax=maximum_flux, cbar_label=cbar_label, title=map_title)
                    if i_quantity in [4, 5] and not self.parse_args.no_vec:
                        # For PI and P, plot polarization vectors
                        self.file_io.read_polarization_vectors_healpix(plot_data[:, i_wl, ...], header)
                # Save figure to pdf file or print it on screen
                plot.save_figure(self.file_io)

    def plot_sed(self):
        """Plot Raytrace or Monte-Carlo results as SED from POLARIS simulations.
        """
        # Set data input to Jy/px to calculate the total flux
        if self.parse_args.cmap_unit is None:
            self.file_io.cmap_unit = 'total'
        # Read raytrace results from file
        sed_data, header, _ = self.file_io.read_emission_sed(
            'polaris_detector_nr' + str(self.detector_index).zfill(4) + '_sed')
        # Set stop_index to maximum number of wavelengths
        if self.stop_index is None or self.stop_index > int(header['nr_wavelengths']):
            self.stop_index = int(header['nr_wavelengths'])
        if self.start_index > int(header['nr_wavelengths']):
            raise ValueError('Chosen wavelength(s) are not in the fits file.\n'
                'It is not the ID from the dust catalog, '
                'but the id of all simulated wavelength of the chosen detector!')
        # Create pdf file if show_plot is not chosen
        self.file_io.init_plot_output('polaris_detector_nr' + str(self.start_index).zfill(4) + '_to_nr' +
                                      str(self.stop_index).zfill(4) + '_sed')
        # Init wavelengths
        wavelengths = header['wavelengths'][self.start_index - 1:self.stop_index]
        # Create one plot per component of the simulation
        for i_quantity in range(self.quantity_index_start - 1, self.quantity_index_stop):
            # Create Matplotlib figure
            plot = Plot(self.model, self.parse_args, xlabel=r'$\lambda\ [\mathsf{m}]$',
                        ylabel=self.file_io.get_quantity_labels(i_quantity), with_cbar=False)
            quantity = sed_data[i_quantity, self.start_index - 1:self.stop_index]
            # Plot spectral energy distribution
            if i_quantity in [0, 4, 6, 7]:
                plot.plot_line(wavelengths, quantity, log='xy', marker='.')
            else:
                plot.plot_line(wavelengths, quantity, log='x', marker='.')
            # Save figure to pdf file or print it on screen
            plot.save_figure(self.file_io)

    def plot_full_sed(self):
        """Plot Raytrace and Monte-Carlo results as SED from POLARIS simulations.
        """
        # Set data input to Jy/px to calculate the total flux
        if self.parse_args.cmap_unit is None:
            self.file_io.cmap_unit = 'total'
        # Plot only the intensity as a full sed plot
        i_quantity = 0
        # Create Matplotlib figure
        plot = Plot(self.model, self.parse_args, xlabel=r'$\lambda\ [\mathsf{m}]$',
                    ylabel=self.file_io.get_quantity_labels(0), with_cbar=False)
        # Set paths of each simulation
        self.file_io.set_path_from_str('plot', self.parse_args.model_name, self.parse_args.simulation_name, 'dust')
        # Read raytrace results from file
        ray_data, ray_header, _ = self.file_io.read_emission_sed('polaris_detector_nr' + str(self.detector_index).zfill(4) + '_sed')
        # Create pdf file if show_plot is not chosen
        self.file_io.init_plot_output('polaris_detector_nr' + str(self.detector_index).zfill(4) + '_sed')
        # Plot spectral energy distribution
        plot.plot_line(ray_header['wavelengths'], ray_data[i_quantity, :],log='y', label=r'$\mathsf{thermal\ emission}$', marker='.')

        # Set paths of each simulation
        self.file_io.set_path_from_str('plot', self.parse_args.model_name, self.parse_args.simulation_name, 'dust_mc')
        # Read raytrace results from file
        mc_data, mc_header, _ = self.file_io.read_emission_sed('polaris_detector_nr' + str(self.detector_index).zfill(4) + '_sed')
        # Plot spectral energy distribution (direct)
        plot.plot_line(mc_header['wavelengths'], mc_data[6, :], log='y', label=r'$\mathsf{direct\ starlight}$', marker='.')
        # Plot spectral energy distribution (scattered)
        plot.plot_line(mc_header['wavelengths'], mc_data[7, :], log='y', label=r'$\mathsf{scattered\ starlight}$', marker='.')
        wavelengths_total = []
        quantity_total = []
        offset = 0
        for i_wl in range(mc_header['nr_wavelengths'] + ray_header['nr_wavelengths']):
            if i_wl - offset >= ray_header['nr_wavelengths']:
                break
            elif i_wl >= mc_header['nr_wavelengths']:
                wavelengths_total.append(ray_header['wavelengths'][i_wl - offset])
                quantity_total.append(ray_data[i_quantity, i_wl - offset])
            elif mc_header['wavelengths'][i_wl] == ray_header['wavelengths'][i_wl - offset]:
                wavelengths_total.append(mc_header['wavelengths'][i_wl])
                quantity_total.append(mc_data[i_quantity, i_wl] + ray_data[0, i_wl - offset])
            elif mc_header['wavelengths'][i_wl] < ray_header['wavelengths'][i_wl - offset]:
                offset += 1
                wavelengths_total.append(mc_header['wavelengths'][i_wl])
                quantity_total.append(mc_data[i_quantity, i_wl])
        # Plot total spectral energy distribution
        plot.plot_line(np.array(wavelengths_total), np.array(quantity_total), log='xy', linestyle='--',
                       label=r'$\mathsf{total\ SED}$', marker='.')
        # Plot the legend
        plot.plot_legend()
        # Save figure to pdf file or print it on screen
        plot.save_figure(self.file_io)

    def plot_midplane(self):
        """Plot midplane data from POLARIS simulations.
        """
        #: List: Combination of possible midplane files (source)
        sources = ['input', 'output']
        #: List: Combination of possible midplane files (quantities)
        quantities = ['gas_number_density', 'gas_mass_density', 
            'dust_number_density', 'dust_mass_density', 'gas_temperature', 
            'dust_temperature', 'mag_field', 'vel_field', 'rat_aalig',
            'delta', 'mach', 'larm', 'dust_choice', 'a_min', 'a_max']
        #: List: Combination of possible midplane files (planes)
        planes = ['xy', 'xz', 'yz']
        if self.parse_args.visualization_input[0] == 'all':
            #: bool: Ignore errors if midplane was not found
            skip_not_known = True
            # Mix together all combination of midplanes to make a plot o each
            if self.parse_args.simulation_type not in ['temp', 'rat']:
                sources = ['input']
            visualization_input_list = []
            for source in sources:
                for quantity in quantities:
                    for plane in planes:
                        visualization_input_list.append(source + '_' + quantity + '_' + plane)
        else:
            #: bool: Do not ignore errors if midplane was not found
            skip_not_known = False
            # Init source of the midplane
            if self.parse_args.visualization_input[0] in sources:
                source = self.parse_args.visualization_input[0]
            else:
                raise ValueError('Source of midplane plot is not correct (input or output)!')
            # Init quantity of the midplane
            if self.parse_args.visualization_input[1] in quantities:
                quantity = self.parse_args.visualization_input[1]
            else:
                raise ValueError('Quantity of midplane plot is not correct (try all)!')
            # Init
            if self.parse_args.visualization_input[2] in planes:
                plane = self.parse_args.visualization_input[2]
            else:
                raise ValueError('Plane of midplane plot is not correct (xy, xz, or yz)!')
            visualization_input_list = [source + '_' + quantity + '_' + plane]
        # Check wich data type the midplane files have (here only map, cut or radial chosen by user)
        plot_data, _, plot_data_type = self.file_io.read_midplane_file(
                visualization_input_list[0], skip_not_known=skip_not_known)
        # Create pdf file if show_plot is not chosen and read map data from file
        if plot_data_type == 'map':
            if self.parse_args.visualization_input[0] == 'all':
                self.file_io.init_plot_output('all_midplanes')
            else:
                self.file_io.init_plot_output(visualization_input_list[0])
        elif plot_data_type == 'cut':
            if self.parse_args.visualization_input[0] == 'all':
                self.file_io.init_plot_output('all_midplanes_cut')
            else:
                self.file_io.init_plot_output(visualization_input_list[0] + '_cut')
        elif plot_data_type == 'radial':
            if self.parse_args.visualization_input[0] == 'all':
                self.file_io.init_plot_output('all_midplanes_radial')
            else:
                self.file_io.init_plot_output(visualization_input_list[0] + '_radial')
        else:
            raise ValueError('Chosen plot type created from midplane is not known!')

        for visualization_input in visualization_input_list:
            # Read midplane data including a vector field
            plot_data, _, plot_data_type = self.file_io.read_midplane_file(
                    visualization_input, skip_not_known=skip_not_known)
            if plot_data is None:
                print('Midplane ' + visualization_input + ' was not found! Skip this midplane.')
            elif plot_data_type == 'map':
                # Extract 1D information from data
                [plot_data, vec_field_data] = plot_data
                # Update the axes label to fit the axes used in the midplane file
                if 'xy' in visualization_input:
                    label_plane = 'xy'
                elif 'xz' in visualization_input:
                    label_plane = 'xz'
                else:
                    label_plane = 'yz'
                # Create Matplotlib figure
                plot = Plot(self.model, self.parse_args, label_plane=label_plane)
                if self.parse_args.visualization_input[0] == 'all' or self.parse_args.plot_title:
                    plot.plot_title(r'$\mathsf{' + visualization_input.replace(r'_', r'\ ') + '}$')
                # Limit data to reasonable values
                plot_data[np.where(plot_data <= 1e-30)] = 0
                # Plot midplane data depending on quantity derived from filename
                self.plot_midplane_map_base(visualization_input, plot, plot_data, vec_field_data)
                # Save figure to pdf file or print it on screen
                plot.save_figure(self.file_io)
            elif plot_data_type == 'cut' or plot_data_type == 'radial':
                # Extract 1D information from data
                [position, data] = plot_data
                # Create Matplotlib figure
                plot = Plot(self.model, self.parse_args, with_cbar=False,
                    ylabel='__placeholder__', limits=[position[0], position[-1], None, None])
                if self.parse_args.visualization_input[0] == 'all' or self.parse_args.plot_title:
                    plot.plot_title(r'$\mathsf{' + visualization_input.replace(r'_', r'\ ') + '}$')
                # Limit data to reasonable values
                data[np.where(data <= 1e-30)] = 0
                # Plot midplane data depending on quantity derived from filename
                self.plot_midplane_1d_base(visualization_input, plot, position, data)
                # Save figure to pdf file or print it on screen
                plot.save_figure(self.file_io)
            else:
                raise ValueError('Midplane plot cannot be created from midplane fits file!')


    def plot_midplane_map_base(self, midplane_name, plot, tbldata, vec_field_data, **args):
        """Plot midplane data depending on quantity derived from filename.

        Args:
            midplane_name (str): Name of the midplane file.
            plot: Instance of Plot class.
            tbldata: 2D map of midplane file.
            vec_field_data: 2D Vector map of midplane file.
        """
        if 'number_density' in midplane_name:
            if 'gas' in midplane_name:
                # Logarithmic plot for density
                plot.plot_imshow(tbldata, cbar_label=r'$n_\mathsf{gas}\ [\si{\per\cubic\metre}}]$', **args)
            if 'dust' in midplane_name:
                # Logarithmic plot for density
                plot.plot_imshow(tbldata, cbar_label=r'$n_\mathsf{dust}\ [\si{\per\cubic\metre}}]$', **args)
        elif 'mass_density' in midplane_name:
            if 'gas' in midplane_name:
                # Logarithmic plot for density
                plot.plot_imshow(tbldata, cbar_label=r'$\rho_\mathsf{gas}\ [\si{\kilogram\per\cubic\metre}]$', **args)
            if 'dust' in midplane_name:
                # Logarithmic plot for density
                plot.plot_imshow(tbldata, cbar_label=r'$\rho_\mathsf{dust}\ [\si{\kilogram\per\cubic\metre}]$', **args)
        elif 'temperature' in midplane_name:
            if 'gas' in midplane_name:
                # Default plot for temperature
                plot.plot_imshow(tbldata, cbar_label=r'$T_\mathsf{gas}\ [\mathsf{K}]$', **args)
            if 'dust' in midplane_name:
                # Default plot for temperature
                plot.plot_imshow(tbldata, cbar_label=r'$T_\mathsf{dust}\ [\mathsf{K}]$', **args)
        elif 'mag' in midplane_name:
            # Change unit if magnetic field is large enough
            if np.nanmax(tbldata) >= 1e-4:
                tbldata = np.multiply(tbldata, 1e4)
                cbar_label = r'$B$\ $[\mathsf{G}]$'
            elif np.nanmax(tbldata) >= 1e-7:
                tbldata = np.multiply(tbldata, 1e7)
                cbar_label = r'$B$\ $[\mathsf{mG}]$'
            else:
                tbldata = np.multiply(tbldata, 1e10)
                cbar_label = r'$B$\ $[\mathsf{\mu G}]$'
            # Default plot for magnetic field
            plot.plot_imshow(tbldata, cbar_label=cbar_label, **args)
            if not self.parse_args.no_vec:
                # Plot vector field
                vector_color = self.math.get_vector_color(tbldata, cmap=plot.cmap,
                    cmap_scaling=self.parse_args.cmap_scaling, vec_color=self.parse_args.vec_color)
                plot.plot_quiver(vec_field_data, color=vector_color, const_quiver=True)
        elif 'vel' in midplane_name:
            # Change unit if velocity field is large enough
            if np.nanmax(tbldata) >= 1e3:
                tbldata = np.multiply(tbldata, 1e-3)
                cbar_label = r'$v$\ $[\si{\kilo\metre\per\second}]$'
            else:
                cbar_label = r'$v$\ $[\mathsf{m/s}]$'
            # Default plot for velocity field
            plot.plot_imshow(tbldata, cbar_label=cbar_label, **args)
            if not self.parse_args.no_vec:
                # Plot vector field
                vector_color = self.math.get_vector_color(tbldata, cmap=plot.cmap,
                    cmap_scaling=self.parse_args.cmap_scaling, vec_color=self.parse_args.vec_color)
                plot.plot_quiver(vec_field_data, color=vector_color, const_quiver=True)
        elif 'rat_aalig' in midplane_name:
            # Logarithmic plot for aligned radii
            plot.plot_imshow(tbldata, cbar_label=r'$a_\mathsf{align}$\ $[\mathsf{m}]$', **args)
        elif 'delta' in midplane_name:
            # Logarithmic plot for Larmor radius
            plot.plot_imshow(tbldata, cbar_label=r'$\delta$', **args)
        elif 'mach' in midplane_name:
            # Logarithmic plot for Larmor radius
            plot.plot_imshow(tbldata, cbar_label=r'$\mathsf{Mach\ Number}$', **args)
        elif 'larm' in midplane_name:
            # Logarithmic plot for Larmor radius
            plot.plot_imshow(tbldata, cbar_label=r'$\mathsf{larm\ limit}$', **args)
        elif 'dust_choice' in midplane_name:
            # Logarithmic plot for Larmor radius
            plot.plot_imshow(tbldata, cbar_label=r'$\mathsf{dust\ Choice\ ID}$', **args)
        else:
            raise ValueError('Chosen midplane name is not known!')

    def plot_midplane_1d_base(self, midplane_name, plot, position, data):
        """Plot midplane data depending on quantity derived from filename.

        Args:
            midplane_name (str): Name of the midplane file.
            plot: Instance of Plot class.
            position: Position along cut or azimuthally averaged radial profile.
            data: Cut or azimuthally averaged radial profile.
        """
        plot.plot_line(position, data)
        if 'density' in midplane_name:
            if 'gas' in midplane_name and 'density':
                plot.set_ylabel(r'$n_\mathsf{gas}\ [\mathsf{m^{-3}}]$')
            if 'dust' in midplane_name:
                plot.set_ylabel(r'$n_\mathsf{dust}\ [\mathsf{m^{-3}}]$')
        elif 'temperature' in midplane_name:
            if 'gas' in midplane_name and 'density':
                plot.set_ylabel(r'$T_\mathsf{gas}\ [\mathsf{K}]$')
            if 'dust' in midplane_name:
                plot.set_ylabel(r'$T_\mathsf{dust}\ [\mathsf{K}]$')
        elif 'rat_aalig' in midplane_name:
            plot.set_ylabel(r'$a_\mathsf{align}$\ $[\mathsf{m}]$')
        elif 'mag' in midplane_name:
            # Change unit if magnetic field is large enough
            if np.nanmax(data) >= 1e-4:
                data = np.multiply(data, 1e4)
                label = r'$B$\ $[\mathsf{G}]$'
            elif np.nanmax(data) >= 1e-7:
                data = np.multiply(data, 1e7)
                label = r'$B$\ $[\mathsf{mG}]$'
            else:
                data = np.multiply(data, 1e10)
                label = r'$B$\ $[\mathsf{\mu G}]$'
            # Default plot for magnetic field
            plot.set_ylabel(label)
        elif 'vel' in midplane_name:
            # Change unit if velocity field is large enough
            if np.nanmax(data) >= 1e3:
                data = np.multiply(data, 1e-3)
                label = r'$v$\ $[\si{\kilo\metre\per\second}]$'
            else:
                label = r'$v$\ $[\mathsf{m/s}]$'
            # Default plot for velocity field
            plot.set_ylabel(label)
        elif 'larm' in midplane_name:
            plot.set_ylabel(r'$\mathsf{larm\ limit}$')
        elif 'dust_choice' in midplane_name:
            plot.set_ylabel(r'$\mathsf{dust\ Choice\ ID}$')
        else:
            raise ValueError('Chosen midplane name is not known!')

    def plot_velocity_channel_maps(self):
        """Plot velocity channel maps from POLARIS simulations.
        """
        # Create pdf file if show_plot is not chosen and read map data from file
        plot_data, header, plot_data_type = self.file_io.read_vel_maps('vel_channel_maps_species_' +
            str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        if plot_data_type == 'map':
            self.file_io.init_plot_output('vel_channel_maps_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'cut':
            self.file_io.init_plot_output('vel_channel_maps_cut_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'radial':
            self.file_io.init_plot_output('vel_channel_maps_radial_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'healpix':
            self.file_io.init_plot_output('vel_channel_healpix_maps_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        else:
            raise ValueError('Chosen plot type created from vel_map is not known!')
        if plot_data_type == 'map':
            for i_quantity in range(self.quantity_index_start - 1, self.quantity_index_stop):
                cbar_label = self.file_io.get_quantity_labels(i_quantity)
                # Create Matplotlib figure
                if i_quantity == int(self.file_io.n_quantities) - 1:
                    vch_list = [0]
                    nr_y_images = 1
                    nr_x_images = 1
                    nr_images = 1
                else:
                    vch_list, nr_x_images, nr_y_images = self.math.best_vel_map_distribution(
                        header['nr_channels'], self.nr_of_vel_map_plots)
                    nr_images = len(vch_list)
                # Find minima and maxima of all images per quantity
                global_vmin = np.min(plot_data[i_quantity, vch_list, :, :])
                global_vmax = np.max(plot_data[i_quantity, vch_list, :, :])
                if global_vmin <= 0 and self.parse_args.cmap_scaling == 'log':
                    global_vmin = global_vmax * 1e-12
                # Init plot instance
                plot = Plot(self.model, self.parse_args,
                    nr_x_images=nr_x_images, nr_y_images=nr_y_images)
                i_image = 0
                for vch in vch_list:
                    # Get velocity of current channel
                    velocity = self.math.get_velocity(vch, header['nr_channels'], header['max_velocity'])
                    # Take data for current quantity
                    tbldata = plot_data[i_quantity, vch, :, :]
                    if i_quantity in [0]:
                        # Plot chosen quantity to velocity map
                        plot.plot_imshow(tbldata, ax_index=i_image, vmin=global_vmin, vmax=global_vmax,
                            extend='neither')
                    elif i_quantity in [1, 2, 3]:
                        if abs(global_vmin) > global_vmax:
                            global_vmax = abs(global_vmin)
                        # Plot polarization fluxes symmetrically around zero
                        plot.plot_imshow(tbldata, ax_index=i_image, cmap='coolwarm',
                            vmin=-global_vmax, vmax=global_vmax, extend='neither')
                    else:
                        plot.plot_imshow(tbldata, ax_index=i_image,
                            vmin=global_vmin, vmax=global_vmax, extend='neither')
                    # Print velocity into image if title is enabled
                    if self.parse_args.plot_title or nr_images > 1:
                        vector_color = self.math.get_vector_color(tbldata, cmap=plot.cmap,
                            cmap_scaling=self.parse_args.cmap_scaling, vec_color=self.parse_args.vec_color)
                        plot.plot_text(text_pos=[0.5, 0.94], relative_position=True,
                            text=r'$v=\SI{' + str(round(velocity * 1e-3, 2)) + r'}{\kilo\metre\per\second}$',
                            ax_index=i_image, color=vector_color)
                    i_image += 1
                # Plot one colorbar for all images
                plot.plot_colorbar(extend='neither', label=cbar_label)
                plot.check_ticks()
                # Save figure to pdf file or print it on screen
                plot.save_figure(self.file_io)
        elif plot_data_type in ['cut', 'radial']:
            # Extract 1D information from data
            [position, data] = plot_data
            for i_quantity in range(self.quantity_index_start - 1, self.quantity_index_stop):
                cbar_label = self.file_io.get_quantity_labels(i_quantity)
                # Create Matplotlib figure
                plot = Plot(self.model, self.parse_args, with_cbar=False, ylabel=cbar_label,
                    limits=[position[0], position[-1], None, None])
                vch_list, nr_x_images, nr_y_images = self.math.best_vel_map_distribution(
                    header['nr_channels'], self.nr_of_vel_map_plots)
                for vch in vch_list:
                    # Get velocity of current channel
                    velocity = self.math.get_velocity(vch, header['nr_channels'], header['max_velocity'])
                    # Plot cut/radial profile
                    plot.plot_line(position, data[i_quantity, vch, :],
                        label=r'$v=\SI{' + str(round(velocity, 1)) + r'}{\metre\per\second}$')
                # Plot the legend
                plot.plot_legend()
                # Save figure to pdf file or print it on screen
                plot.save_figure(self.file_io)
        elif plot_data_type == 'healpix':
            for i_quantity in range(self.quantity_index_start - 1, self.quantity_index_stop):
                # Find minima and maxima of all images per quantity
                global_vmin = np.min(plot_data[i_quantity, :, ...])
                global_vmax = np.max(plot_data[i_quantity, :, ...])
                if global_vmin <= 0 and self.parse_args.cmap_scaling == 'log':
                    global_vmin = global_vmax * 1e-12
                for vch in range(header['nr_channels']):
                    cbar_label = self.file_io.get_quantity_labels(i_quantity)
                    # Take data for current quantity
                    wmap_map = plot_data[i_quantity, vch, :]
                    # Create Matplotlib figure
                    plot = Plot(self.model, self.parse_args, image_type='healpix')
                    # Get velocity of current channel
                    velocity = self.math.get_velocity(vch, header['nr_channels'], header['max_velocity'])
                    # Print velocity into image if title is enabled
                    if self.parse_args.plot_title:
                        vector_color = self.math.get_vector_color(tbldata, cmap=plot.cmap,
                            cmap_scaling=self.parse_args.cmap_scaling, vec_color=self.parse_args.vec_color)
                        plot.plot_text(text_pos=[0.5, 0.94], relative_position=True,
                            text=r'$v=\SI{' + str(round(velocity, 1)) + r'}{\metre\per\second}$', color=vector_color)
                    if i_quantity in [1, 2, 3]:
                        if abs(global_vmin) > global_vmax:
                            global_vmax = abs(global_vmin)
                        # Plot polarization fluxes symmetrically around zero
                        plot.plot_healpix(wmap_map, cmap='coolwarm', vmin=-global_vmax,
                            vmax=global_vmax, cbar_label=cbar_label)
                    elif i_quantity == 5:
                        if vch == 0:
                            plot.plot_healpix(wmap_map, cbar_label=cbar_label)
                    else:
                        plot.plot_healpix(wmap_map, cbar_label=cbar_label, vmin=global_vmin,
                            vmax=global_vmax)
                    # Save figure to pdf file or print it on screen
                    plot.save_figure(self.file_io)



    def plot_int_velocity_channel_map(self):
        """Plot integrated velocity channel map from POLARIS simulations.
        """
        plot_data, _, plot_data_type = self.file_io.read_int_vel_map('int_channel_map_species_' +
            str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        # Create pdf file if show_plot is not chosen and read map data from file
        if plot_data_type == 'map':
            self.file_io.init_plot_output('int_channel_map_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'cut':
            self.file_io.init_plot_output('int_channel_map_cut_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'radial':
            self.file_io.init_plot_output('int_channel_map_radial_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'healpix':
            self.file_io.init_plot_output('int_channel_healpix_map_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        else:
            raise ValueError('Chosen plot type created from int_map is not known!')
        for i_quantity in range(self.quantity_index_start - 1, self.quantity_index_stop):
            cbar_label = self.file_io.get_quantity_labels(i_quantity, int_map=True)
            if plot_data_type == 'map':
                # Create Matplotlib figure
                plot = Plot(self.model, self.parse_args)
                # Take data for current quantity
                tbldata = plot_data[i_quantity, :, :]
                if i_quantity is 0:
                    # Plot chosen quantity to velocity map
                    plot.plot_imshow(tbldata, cbar_label=self.file_io.get_quantity_labels(i_quantity, int_map=True))
                elif i_quantity in [1, 2, 3]:
                    # Plot polarization fluxes symmetrically around zero
                    if np.nanmax(np.abs(plot_data)) > 0.:
                        maximum_flux = np.asscalar(np.nanmax(np.abs(tbldata)))
                    else:
                        maximum_flux = 1.0
                    plot.plot_imshow(tbldata, cmap='coolwarm', vmin=-maximum_flux,
                        vmax=maximum_flux, cbar_label=cbar_label, extend='neither')
                else:
                    plot.plot_imshow(tbldata, cbar_label=cbar_label)
            elif plot_data_type in ['cut', 'radial']:
                # Extract 1D information from data
                [position, data] = plot_data
                # Create Matplotlib figure
                plot = Plot(self.model, self.parse_args, with_cbar=False,
                            ylabel=cbar_label, limits=[position[0], position[-1], None, None])
                # Plot cut/radial profile
                plot.plot_line(position, data[i_quantity, :])
            elif plot_data_type == 'healpix':
                # Take data for current quantity
                wmap_map = plot_data[i_quantity, :]
                # Create Matplotlib figure
                plot = Plot(self.model, self.parse_args, image_type='healpix')
                if i_quantity in [1, 2, 3]:
                    # Plot polarization fluxes symmetrically around zero
                    if np.nanmax(np.abs(wmap_map)) > 0.:
                        maximum_flux = np.asscalar(np.nanmax(np.abs(wmap_map)))
                    else:
                        maximum_flux = 1.0
                    plot.plot_healpix(wmap_map, cmap='coolwarm', vmin=-maximum_flux,
                        vmax=maximum_flux, cbar_label=cbar_label)
                else:
                    plot.plot_healpix(wmap_map, cbar_label=cbar_label)
            # Save figure to pdf file or print it on screen
            plot.save_figure(self.file_io)

    def plot_line_spectrum(self):
        """Plot line spectrum from POLARIS simulations.
        """
        # Set data input to Jy to calculate the total flux
        self.file_io.cmap_unit = 'total'
        # Read spectrum data
        plot_data, header = self.file_io.read_spectrum('line_spectrum_species_' +
            str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        # Create pdf file if show_plot is not chosen
        self.file_io.init_plot_output('line_spectrum_species_' +
            str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        velocity = []
        for vch in range(header['nr_channels']):
            # Get velocity of current channel
            velocity.append(1e-3 * self.math.get_velocity(vch, header['nr_channels'], header['max_velocity']))
        for i_quantity in range(self.quantity_index_start - 1, min(4, self.quantity_index_stop)):
            # Create Matplotlib figure
            plot = Plot(self.model, self.parse_args, xlabel=r'$\mathit{v}\ [\si{\kilo\metre\per\second}]$',
                        ylabel=self.file_io.get_quantity_labels(i_quantity),
                        extent=[velocity[0], velocity[-1], None, None], with_cbar=False)
            # Plot spectrum as line
            plot.plot_line(velocity, plot_data[i_quantity, :], step=True)
            # Save figure to pdf file or print it on screen
            plot.save_figure(self.file_io)

    def plot_zeeman_mag_field_map(self):
        """Plot magnetic field strength map from Zeeman splitting.

        Notes:
            See Crutcher et al. (1993)
        """
        # Create pdf file if show_plot is not chosen and read map data from file
        plot_data, header, plot_data_type = self.file_io.read_vel_maps('vel_channel_maps_species_' +
            str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        if plot_data_type == 'map':
            self.file_io.init_plot_output('magnetic_field_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'cut':
            self.file_io.init_plot_output('magnetic_field_cut_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'radial':
            self.file_io.init_plot_output('magnetic_field_radial_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'healpix':
            self.file_io.init_plot_output('magnetic_field_healpix_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        else:
            raise ValueError('Chosen plot type created from vel_map is not known!')
        # Old version of POLARIS used 5th column and new version has 6th column magnetic field and 4th column tau
        mag_field_index = np.size(plot_data, 0) - 1
        if plot_data_type == 'map':
            mag_field_list, labels = self.plot_zeeman_mag_field_base(plot_data[0, :, ...], plot_data[3, :, ...],
                plot_data[mag_field_index, 1, ...], header)
            # List for the differen plot quantities/parameters
            limits = [np.asscalar(np.nanmax(np.abs(mag_field_list[0]))),
                np.asscalar(np.nanmax(np.abs(mag_field_list[1]))),
                np.asscalar(np.nanmax(np.abs(mag_field_list[2]))), None,
                np.asscalar(np.nanmax(np.abs(mag_field_list[4]))), None]
            for i_quantity in range(self.quantity_index_start - 1, self.quantity_index_stop):
                # Create Matplotlib figure
                plot = Plot(self.model, self.parse_args)
                # Plot quantity to velocity map
                if limits[i_quantity] is None:
                    plot.plot_imshow(mag_field_list[i_quantity], cbar_label=labels[i_quantity])
                else:
                    plot.plot_imshow(mag_field_list[i_quantity], cbar_label=labels[i_quantity],
                        cmap='coolwarm', vmin=-limits[i_quantity], vmax=limits[i_quantity], extend='neither')
                # Save figure to pdf file or print it on screen
                plot.save_figure(self.file_io)
        elif plot_data_type in ['cut', 'radial']:
            # Extract 1D information from data
            [position, tmp_data] = plot_data
            mag_field_list, labels = self.plot_zeeman_mag_field_base(tmp_data[0, :, ...], tmp_data[3, :, ...],
                tmp_data[mag_field_index, 1, ...], header)
            for i_quantity in range(self.quantity_index_start - 1, self.quantity_index_stop):
                # Create Matplotlib figure
                plot = Plot(self.model, self.parse_args, with_cbar=False,
                            ylabel=labels[i_quantity], limits=[position[0], position[-1], None, None])
                # Plot quantity to velocity map
                plot.plot_line(position, mag_field_list[i_quantity])
                # Save figure to pdf file or print it on screen
                plot.save_figure(self.file_io)
        elif plot_data_type == 'healpix':
            mag_field_list, labels = self.plot_zeeman_mag_field_base(plot_data[0, :, ...], plot_data[3, :, ...],
                plot_data[mag_field_index, 1, ...], header)
            # List for the differen plot quantities/parameters
            limits = [np.asscalar(np.nanmax(np.abs(mag_field_list[0]))),
                np.asscalar(np.nanmax(np.abs(mag_field_list[1]))),
                np.asscalar(np.nanmax(np.abs(mag_field_list[2]))), None,
                np.asscalar(np.nanmax(np.abs(mag_field_list[4]))), None]
            for i_quantity in range(self.quantity_index_start - 1, self.quantity_index_stop):
                # Create Matplotlib figure
                plot = Plot(self.model, self.parse_args, image_type='healpix')
                # Plot quantity to velocity map
                if limits[i_quantity] is None:
                    plot.plot_healpix(mag_field_list[i_quantity], cbar_label=labels[i_quantity])
                else:
                    plot.plot_healpix(mag_field_list[i_quantity], cbar_label=labels[i_quantity],
                        cmap='coolwarm', vmin=-limits[i_quantity], vmax=limits[i_quantity])
                # Save figure to pdf file or print it on screen
                plot.save_figure(self.file_io)

    def plot_zeeman_mag_field_base(self, data_I, data_V, ref_mag_field_strength, header):
        """Estimate the magnetic  field strength from zeeman signal.

        Args:
            data_I: 2D-3D Array of the intensity.
            data_V: 2D-3D Array of the circularly polarized fraction.
            ref_mag_field_strength: 1D-2D Array with the magnetic field strength inside of the model.
            header (dict): Header of the velocity channel map fits file.

        Return:
            List: List of magnetic fields and their differences between derived and model field strength.
        """
        # Get gas module
        from modules.gas import GasChooser
        gas_chooser = GasChooser(self.file_io, self.parse_args)
        gas = gas_chooser.get_module_from_name(header['species_name'])
        if not gas.parameter['zeeman_usable']:
            raise ValueError('No magnetic field calculations are defined for the gas species ' +
                header['species_name'] + '!')
        # Calculate velocity width of a channel
        vel_channel_width = 2. * header['max_velocity'] / header['nr_channels']
        # Get shape of the data
        shape = data_I[0, ...].shape
        # Initialise output arrays for the derived and reference magnetic field strength
        derived_magnetic_field = np.zeros(shape)
        reference_magnetic_field = np.zeros(shape)
        magnetic_field_difference = np.zeros(shape)
        magnetic_field_rel_difference = np.zeros(shape)
        abs_magnetic_field_rel_difference = np.zeros(shape)
        #: str: Colorbar label addon
        cbar_label_addon = ''
        # Get maximum magnetic field strength to set the correct scaling (micro G, mG, G)
        max_mag_field_value = np.nanmax(ref_mag_field_strength)
        # Calculate velocity shift by comparing I and V profiles
        velocity_shift = self.math.velocity_shift_from_profile(data_I, data_V, vel_channel_width)
        # Channel number 0 contains the LOS magnetic field strength of the model
        if max_mag_field_value >= 1e-4:
            reference_magnetic_field = ref_mag_field_strength * 1e4
            derived_magnetic_field = gas.shift_2_mag(velocity_shift, header['frequency'], header['i_transition']) * 1e4
            cbar_label_addon = r'$[\mathsf{G}]$'
        elif max_mag_field_value >= 1e-7:
            reference_magnetic_field = ref_mag_field_strength * 1e7
            derived_magnetic_field = gas.shift_2_mag(velocity_shift, header['frequency'], header['i_transition']) * 1e7
            cbar_label_addon = r'$[\mathsf{mG}]$'
        else:
            reference_magnetic_field = ref_mag_field_strength * 1e10
            derived_magnetic_field = gas.shift_2_mag(velocity_shift, header['frequency'], header['i_transition']) * 1e10
            cbar_label_addon = r'$[\mathsf{\mu G}]$'
        magnetic_field_difference = (derived_magnetic_field - reference_magnetic_field)
        mask = reference_magnetic_field != 0
        magnetic_field_rel_difference[mask] = 100. * ((derived_magnetic_field[mask] - reference_magnetic_field[mask]) /
                reference_magnetic_field[mask])
        abs_magnetic_field_rel_difference[mask] = 100. * np.abs(
                derived_magnetic_field[mask] - reference_magnetic_field[mask]) / np.abs(reference_magnetic_field[mask])
        mag_field_list = [derived_magnetic_field, reference_magnetic_field, magnetic_field_difference,
            np.abs(magnetic_field_difference), magnetic_field_rel_difference, abs_magnetic_field_rel_difference]
        labels = [r'$B_\mathsf{LOS}\ $' + cbar_label_addon, r'$B_\mathsf{LOS, model}\ $' + cbar_label_addon,
              r'$B_\mathsf{LOS} - B_\mathsf{LOS, model}\ $' + cbar_label_addon,
              r'$|B_\mathsf{LOS} - B_\mathsf{LOS, model}|\ $' + cbar_label_addon,
              r'$|\Delta B_\mathsf{LOS}|/B_\mathsf{LOS}\ [\%]$', r'$\Delta B_\mathsf{LOS}/B_\mathsf{LOS}\ [\%]$']
        return mag_field_list, labels

    def plot_velocity_map(self):
        """Plot average velocity map from maxima of intensity spectrum.
        """
        # Load necessary modules
        from sys import stdout
        # Create pdf file if show_plot is not chosen and read map data from file
        plot_data, header, plot_data_type = self.file_io.read_vel_maps('vel_channel_maps_species_' +
            str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        if plot_data_type == 'map':
            self.file_io.init_plot_output('average_velocity_map_species_' + str(self.gas_species_index).zfill(4) +
                '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'cut':
            self.file_io.init_plot_output('average_velocity_map_cut_species_' + str(self.gas_species_index).zfill(4) +
                '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'radial':
            self.file_io.init_plot_output('average_velocity_map_radial_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        elif plot_data_type == 'healpix':
            self.file_io.init_plot_output('average_velocity_healpix_map_species_' +
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))
        else:
            raise ValueError('Chosen plot type created from vel_map is not known!')
        # Calculate velocity width of a channel
        vel_channel_width = 2. * header['max_velocity'] / (header['nr_channels'] - 1)
        if plot_data_type == 'map':
            # Initialise output arrays for the derived and reference magnetic field strength
            velocity = np.zeros((header['nr_pixel_x'], header['nr_pixel_y']))
            for i_x in range(header['nr_pixel_x']):
                for i_y in range(header['nr_pixel_y']):
                    stdout.write('--- Calculate average velocity for each pixel: ' + str(int(100. *
                        (i_x * header['nr_pixel_y'] + i_y + 1) /
                        (header['nr_pixel_x'] * header['nr_pixel_y']))) + ' %                 \r')
                    stdout.flush()
                    velocity[i_x, i_y] = -header['max_velocity'] + \
                        np.argmax(plot_data[0, :, i_x, i_y]) * vel_channel_width
            # Create Matplotlib figure
            plot = Plot(self.model, self.parse_args)
            # Plot quantity to velocity map
            plot.plot_imshow(velocity, cbar_label=r'$v\ [\si{\kilo\metre\per\second}]$', cmap='coolwarm',
                             vmin=-np.asscalar(np.nanmax(np.abs(velocity))),
                             vmax=np.asscalar(np.nanmax(np.abs(velocity))), extend='neither')
        elif plot_data_type in ['cut', 'radial']:
            # Extract 1D information from data
            [position, data] = plot_data
            # Get number of 1D profile values
            N = position.shape[-1]
            # Initialise output arrays for the derived and reference magnetic field strength
            velocity = np.zeros(N)
            for i in range(N):
                stdout.write('--- Calculate average velocity for each pixel along the cut/radial profile: ' +
                    str(int(100. * (i + 1) / N)) + ' %                             \r')
                stdout.flush()
                velocity[i] = -header['max_velocity'] + np.argmax(data[0, :, i]) * vel_channel_width
            # Create Matplotlib figure
            plot = Plot(self.model, self.parse_args, with_cbar=False,
                        ylabel=r'$v\ [\si{\kilo\metre\per\second}]$')
            # Plot quantity to velocity map
            plot.plot_line(position, velocity)
        # Save figure to pdf file or print it on screen
        plot.save_figure(self.file_io)

    def combine_emission_maps(self):
        """Combining (adding) the resulting fits of Monte-Carlo and raytracing simulations together.
        """
        from astropy.io import fits
        emission_types = ['dust_mc', 'dust']
        for i in range(len(emission_types)):
            hdul = fits.open(self.file_io.path['simulation'] + emission_types[i] +
                             '/data/polaris_detector_nr' + str(self.detector_index).zfill(4))
            if i == 0:
                final_hdul = hdul
                shape = np.shape(hdul[0].data[0:6, :, :, :])
                final_data = np.zeros(shape)
            else:
                header_ray, _ = self.file_io.read_emission_map_header(hdul)
                header_mc, _ = self.file_io.read_emission_map_header(final_hdul)
                if header_ray['nr_wavelengths'] != header_mc['nr_wavelengths']:
                    raise ValueError('Number of wavelength does not match!')
                if header_ray['wavelengths'] != header_mc['wavelengths']:
                    raise ValueError('Wavelengths do not match!')
            tmp_data = hdul[0].data
            final_data[0:4, :, :, :] += tmp_data[0:4, :, :, :]
            if emission_types[i] == 'dust':
                final_data[4, :, :, :] += tmp_data[0, :, :, :]
            else:
                final_data[4:6, :, :, :] += tmp_data[4:6, :, :, :]
            final_hdul[0].header['ETYPE'] = 'total emission', 'type of emission'
        final_hdul[0].data = final_data
        final_hdul.writeto(self.file_io.path['simulation'] + 'dust_full/data/polaris_detector_nr' +
                           str(self.detector_index).zfill(4) + '.fits', overwrite=True)
        final_hdul.close()

    def convert_fits_casa(self):
        """Convert fits to be used in CASA.
        """
        if self.parse_args.simulation_type == 'line':
            hdulist = self.file_io.read_vel_maps('vel_channel_maps_species_' + 
                str(self.gas_species_index).zfill(4) + '_line_' + str(self.spectral_line_index).zfill(4))

            hdulist[0].data = hdulist[0].data[3, :, :, :]
            hdulist[0].header['NAXIS'] = 3
            del hdulist[0].header['CTYPE4']
            del hdulist[0].header['CRVAL4']
            del hdulist[0].header['CRPIX4']
            del hdulist[0].header['CDELT4']
            del hdulist[0].header['CUNIT4']
            hdulist[0].header['BUNIT'] = 'Jy/pixel'
            hdulist[0].header['CTYPE1'] = 'RA---TAN'
            arcsec_per_pixel = ((2. * self.model.tmp_parameter['radius_arcsec'])
                                / hdulist[0].header['NAXIS1']) * (np.pi / (3600. * 180.))
            hdulist[0].header['CRVAL1'] = -self.model.parameter[
                'radius_arcsec'] + 0.5 * arcsec_per_pixel
            hdulist[0].header['CRPIX1'] = 1
            hdulist[0].header['CDELT1'] = arcsec_per_pixel
            hdulist[0].header['CUNIT1'] = 'rad'
            hdulist[0].header['CTYPE2'] = 'DEC--TAN'
            arcsec_per_pixel = ((2. * self.model.tmp_parameter['radius_arcsec'])
                                / hdulist[0].header['NAXIS2']) * (np.pi / (3600. * 180.))
            hdulist[0].header['CRVAL2'] = -self.model.parameter[
                'radius_arcsec'] + 0.5 * arcsec_per_pixel
            hdulist[0].header['CRPIX2'] = 1
            hdulist[0].header['CDELT2'] = arcsec_per_pixel
            hdulist[0].header['CUNIT2'] = 'rad'
            hdulist[0].header['CTYPE3'] = 'FREQ'
            hdulist[0].header['CRVAL3'] = (hdulist[0].header['CRVAL3'] /
                                           self.math.const['c'] + 1.) * hdulist[0].header['FREQ']
            hdulist[0].header['CRPIX3'] = 1
            hdulist[0].header['CDELT3'] = (hdulist[0].header['CDELT3'] /
                   self.math.const['c']) * hdulist[0].header['FREQ']
            hdulist[0].header['CUNIT3'] = 'Hz'
            hdulist.writeto(self.file_io.path['results'] + 'new.fits', clobber=True)
        else:
            print('--- Error: Fits file cannot be loaded!')

    def get_custom_routine(self):
        """Execute personalized routines from custom_plots.py.
        """
        from custom.plots import CustomPlots
        custom_plots = CustomPlots(self, self.model, self.file_io, self.parse_args)
        routine_number = int(self.parse_args.visualization_input[0])
        CustomPlots.__dict__['plot_' + str(routine_number)](custom_plots)

    def finish_plots(self):
        # Close pdf file if used
        self.file_io.close_plot_output()

    def set_plot_indizes(self):
        """Set the indices for visualizations depending on the user input.
        """
        if self.parse_args.visualization_type == 'map':
            self.file_io.n_quantities += 2

        if self.parse_args.visualization_type in ['map', 'sed']:
            if len(self.parse_args.visualization_input) == 1:
                '''
                Use all wavelengths and quantities for one detector
                    detector index = visualization_input_0
                '''
                self.detector_index = int(self.parse_args.visualization_input[0])
                self.start_index = 1
                self.stop_index = None
                self.quantity_index_start = 1
                self.quantity_index_stop = int(self.file_io.n_quantities)
            elif len(self.parse_args.visualization_input) == 2:
                '''
                Use one wavelength and all quantities for one detector
                    detector index = visualization_input_0
                    wavelength index = visualization_input_1
                '''
                self.detector_index = int(self.parse_args.visualization_input[0])
                self.start_index = int(self.parse_args.visualization_input[1])
                self.stop_index = int(self.parse_args.visualization_input[1])
                self.quantity_index_start = 1
                self.quantity_index_stop = int(self.file_io.n_quantities)
            elif len(self.parse_args.visualization_input) == 3:
                '''
                Use a range of wavelengths and all quantities for one detector
                    detector index = visualization_input_0
                    wavelength index start = visualization_input_1
                    wavelength index stop = visualization_input_2
                '''
                self.detector_index = int(self.parse_args.visualization_input[0])
                self.start_index = int(self.parse_args.visualization_input[1])
                self.stop_index = int(self.parse_args.visualization_input[2])
                self.quantity_index_start = 1
                self.quantity_index_stop = int(self.file_io.n_quantities)
            elif len(self.parse_args.visualization_input) == 4:
                '''
                Use a range of wavelengths and one quantities for one detector
                    detector index = visualization_input_0
                    wavelength index start = visualization_input_1
                    wavelength index stop = visualization_input_2
                    quantity index (1: I, 2: Q, ...) = visualization_input_3
                '''
                self.detector_index = int(self.parse_args.visualization_input[0])
                self.start_index = int(self.parse_args.visualization_input[1])
                self.stop_index = int(self.parse_args.visualization_input[2])
                self.quantity_index_start = int(self.parse_args.visualization_input[3])
                self.quantity_index_stop = int(self.parse_args.visualization_input[3])
            elif len(self.parse_args.visualization_input) == 5:
                '''
                Use a range of wavelengths and a range of quantities for one detector
                    detector index = visualization_input_0
                    wavelength index start = visualization_input_1
                    wavelength index stop = visualization_input_2
                    quantity index start (1: I, 2: Q, ...) = visualization_input_3
                    quantity index stop (1: I, 2: Q, ...) = visualization_input_4
                '''
                self.detector_index = int(self.parse_args.visualization_input[0])
                self.start_index = int(self.parse_args.visualization_input[1])
                self.stop_index = int(self.parse_args.visualization_input[2])
                self.quantity_index_start = int(self.parse_args.visualization_input[3])
                self.quantity_index_stop = int(self.parse_args.visualization_input[4])
            else:
                raise ValueError('Too many visualization_input values with: ' +
                    str(self.parse_args.visualization_input) +  ' !')
        elif self.parse_args.visualization_type in ['int_map', 'vel_map', 'spectrum', 'mag_field', 'velocity']:
            if len(self.parse_args.visualization_input) == 1:
                '''
                Use all quantities for one gas_species
                    spectral line = visualization_input_0
                '''
                self.gas_species_index = 1
                self.spectral_line_index = int(self.parse_args.visualization_input[0])
                self.quantity_index_start = 1
                self.quantity_index_stop = int(self.file_io.n_quantities)
            elif len(self.parse_args.visualization_input) == 2:
                '''
                Use all quantities
                    gas species index = visualization_input_0
                    spectral line index = visualization_input_1
                '''
                self.gas_species_index = int(self.parse_args.visualization_input[0])
                self.spectral_line_index = int(self.parse_args.visualization_input[1])
                self.quantity_index_start = 1
                self.quantity_index_stop = int(self.file_io.n_quantities)
            elif len(self.parse_args.visualization_input) == 3:
                # Use one quantities
                # gas species index = visualization_input_0
                # spectral line index = visualization_input_1
                # quantity index (1: I, 2: Q, ...) = visualization_input_2
                self.gas_species_index = int(self.parse_args.visualization_input[0])
                self.spectral_line_index = int(self.parse_args.visualization_input[1])
                self.quantity_index_start = int(self.parse_args.visualization_input[2])
                self.quantity_index_stop = int(self.parse_args.visualization_input[2])
            elif len(self.parse_args.visualization_input) == 4:
                '''
                Use a range of quantities
                    gas species index = visualization_input_0
                    spectral line index = visualization_input_1
                    quantity index start (1: I, 2: Q, ...) = visualization_input_2
                    quantity index stop (1: I, 2: Q, ...) = visualization_input_3
                '''
                self.gas_species_index = int(self.parse_args.visualization_input[0])
                self.spectral_line_index = int(self.parse_args.visualization_input[1])
                self.quantity_index_start = int(self.parse_args.visualization_input[2])
                self.quantity_index_stop = int(self.parse_args.visualization_input[3])
            else:
                raise ValueError('Too many visualization_input values with: ' +
                    str(self.parse_args.visualization_input) +  ' !')
            if 1 > self.quantity_index_start > int(self.file_io.n_quantities) or \
                    1 > self.quantity_index_stop > int(self.file_io.n_quantities):
                raise ValueError('The chosen quantity range does not exist!')


if __name__ == '__main__':
    print('------------------------- PolarisTools -------------------------')
    print('--- Initialization ...')
    # Load Plot routines after argument parser to allow fast --help display.
    from modules.visual import Plot

    #: Instance of PlotRoutines which can manage POLARIS plot creation
    plot_routines = PlotRoutines(parser_options)
    print('--- Initialization finished!')

    print('--- Create plots from POLARIS results ...')

    error = False
    # OtherRoutines can contain all sorts of plot routines
    if parser_options.visualization_type == 'custom':
        plot_routines.get_custom_routine()
    else:
        if parser_options.simulation_type in ['temp', 'rat', 'temp_rat']:
            # Heat and rat simulations offer only midplane results
            if parser_options.visualization_type == 'midplane':
                plot_routines.plot_midplane()
            else:
                error = True
        elif parser_options.simulation_type == 'dust_mc':
            # Ray simulations offer midplane and raytrace results
            if parser_options.visualization_type == 'midplane':
                plot_routines.plot_midplane()
            elif parser_options.visualization_type == 'map':
                plot_routines.plot_map()
            elif parser_options.visualization_type == 'sed':
                plot_routines.plot_sed()
            # elif parser_options.visualization_type == 'casa':
            #     plot_routines.convert_fits_casa()
            else:
                error = True
        elif parser_options.simulation_type == 'dust_full':
            # Ray simulations offer midplane and raytrace results
            if parser_options.visualization_type == 'map':
                plot_routines.combine_emission_maps()
                plot_routines.plot_map()
            elif parser_options.visualization_type == 'sed':
                plot_routines.combine_emission_maps()
                plot_routines.plot_full_sed()
            else:
                error = True
        elif parser_options.simulation_type == 'dust' or \
                'dust_' in parser_options.simulation_type:
            # dust emission simulations offer midplane and raytrace results
            if parser_options.visualization_type == 'midplane':
                plot_routines.plot_midplane()
            elif parser_options.visualization_type == 'map':
                plot_routines.plot_map()
            elif parser_options.visualization_type == 'sed':
                plot_routines.plot_sed()
            # elif parser_options.visualization_type == 'casa':
            #     plot_routines.convert_fits_casa()
            else:
                error = True
        elif parser_options.simulation_type in ['line', 'zeeman']:
            # Line simulations offer midplane, integrated and normal velocity maps and line spectra
            if parser_options.visualization_type == 'midplane':
                plot_routines.plot_midplane()
            elif parser_options.visualization_type == 'vel_map':
                plot_routines.plot_velocity_channel_maps()
            elif parser_options.visualization_type == 'int_map':
                plot_routines.plot_int_velocity_channel_map()
            elif parser_options.visualization_type == 'spectrum':
                plot_routines.plot_line_spectrum()
            elif parser_options.visualization_type == 'mag_field' and parser_options.simulation_type == 'zeeman':
                plot_routines.plot_zeeman_mag_field_map()
            elif parser_options.visualization_type == 'velocity':
                plot_routines.plot_velocity_map()
            # elif parser_options.visualization_type == 'casa':
            #     plot_routines.convert_fits_casa()
            else:
                error = True
        else:
            error = True
    if error:
        raise ValueError(
            parser_options.simulation_type + ' simulations do not offer the creation of ' +
            parser_options.visualization_type + ' plots!')
    else:
        # Close pdf file if used
        plot_routines.finish_plots()
    print('--- Creation of plots finished!')
